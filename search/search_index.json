{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ImgVisFeat","text":"<p>Image Visualization and Feature Extraction Library</p> <p>ImgVisFeat is a Python library for image visualization and feature extraction, providing a comprehensive set of tools for analyzing and visualizing various image features.</p>"},{"location":"#features","title":"Features","text":"<p>ImgVisFeat provides the following visualization and feature extraction capabilities:</p>"},{"location":"#color-channel-visualization","title":"Color Channel Visualization","text":"<p>Extract and visualize individual RGB color channels to analyze color distribution in images.</p>"},{"location":"#gradient-visualization","title":"Gradient Visualization","text":"<p>Compute and visualize image gradients in X, Y, and combined XY directions:</p> <ul> <li>ColorGradientVisualizer: For color images</li> <li>GrayGradientVisualizer: For grayscale images</li> </ul>"},{"location":"#hog-histogram-of-oriented-gradients","title":"HoG (Histogram of Oriented Gradients)","text":"<p>Visualize feature descriptors commonly used for object detection and recognition.</p>"},{"location":"#lbp-local-binary-patterns","title":"LBP (Local Binary Patterns)","text":"<p>Extract texture descriptors for texture classification and analysis.</p>"},{"location":"#keypoint-detection","title":"Keypoint Detection","text":"<p>Detect and visualize keypoints using multiple algorithms:</p> <ul> <li>SIFT (Scale-Invariant Feature Transform)</li> <li>AKAZE (Accelerated-KAZE)</li> <li>ORB (Oriented FAST and Rotated BRIEF)</li> </ul>"},{"location":"#power-spectrum-analysis","title":"Power Spectrum Analysis","text":"<p>Analyze frequency domain characteristics of images using Fourier Transform.</p>"},{"location":"#cli-tool","title":"CLI Tool","text":"<p>Command-line interface for quick visualizations without writing code.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install ImgVisFeat\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"All-in-One Visualizer <pre><code>```python\nimport imvf\n\n# Create visualizer instance\nvisualizer = imvf.Visualizer()\n\n# Visualize all features and save results\nvisualizer.visualize(\"path/to/image.jpg\")\n```\n</code></pre> Individual Visualizers <pre><code>```python\nimport cv2\nimport imvf\n\n# Load image\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Color channel visualization\ncolor_channel = imvf.ColorChannelVisualizer()\nresult = color_channel(image)\ncv2.imshow(\"Blue Channel\", result.blue)\ncv2.imshow(\"Green Channel\", result.green)\ncv2.imshow(\"Red Channel\", result.red)\n\n# HoG visualization\nhog = imvf.HoGVisualizer()\nresult = hog(image)\ncv2.imshow(\"HoG\", result.hog)\n```\n</code></pre> Command Line <pre><code>```bash\n# Visualize all features\nimvf path/to/image.jpg\n\n# Visualize specific feature\nimvf path/to/image.jpg --method hog\n```\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Installation and basic usage</li> <li>User Guide - Detailed guides for each visualizer</li> <li>CLI Reference - Command-line interface documentation</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.10</li> <li>NumPy</li> <li>OpenCV</li> <li>scikit-image</li> <li>Pydantic &gt;= 2.0.0</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>ImgVisFeat is a personal project created for learning and experimentation. While it's open-source and you're welcome to use and learn from it, please note that it may not be actively maintained or updated regularly.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Issue Tracker</li> </ul>"},{"location":"cli/","title":"Command Line Interface","text":"<p>ImgVisFeat provides a command-line interface (CLI) built with Typer for easy access to its visualization features.</p>"},{"location":"cli/#basic-usage","title":"Basic Usage","text":"<pre><code>imvf [COMMAND] IMAGE_PATH\n</code></pre> <p>The CLI uses subcommands for different visualization methods, making it intuitive and easy to use.</p>"},{"location":"cli/#getting-help","title":"Getting Help","text":"<pre><code># Show main help with all available commands\nimvf --help\n\n# Show help for a specific command\nimvf all --help\nimvf hog --help\n</code></pre>"},{"location":"cli/#available-commands","title":"Available Commands","text":""},{"location":"cli/#all-visualize-all-features","title":"<code>all</code> - Visualize All Features","text":"<p>Applies all visualization methods to the input image.</p> <pre><code>imvf all path/to/image.jpg\n</code></pre>"},{"location":"cli/#color-channel-color-channel-visualization","title":"<code>color-channel</code> - Color Channel Visualization","text":"<p>Extracts and visualizes individual RGB color channels.</p> <pre><code>imvf color-channel path/to/image.jpg\n</code></pre>"},{"location":"cli/#gradient-gradient-visualization","title":"<code>gradient</code> - Gradient Visualization","text":"<p>Computes and visualizes image gradients in X, Y, and combined XY directions.</p> <pre><code>imvf gradient path/to/image.jpg\n</code></pre>"},{"location":"cli/#hog-histogram-of-oriented-gradients","title":"<code>hog</code> - Histogram of Oriented Gradients","text":"<p>Visualizes HoG feature descriptors for object detection.</p> <pre><code>imvf hog path/to/image.jpg\n</code></pre>"},{"location":"cli/#keypoint-keypoint-detection","title":"<code>keypoint</code> - Keypoint Detection","text":"<p>Detects and visualizes keypoints using SIFT, AKAZE, and ORB algorithms.</p> <pre><code>imvf keypoint path/to/image.jpg\n</code></pre>"},{"location":"cli/#lbp-local-binary-patterns","title":"<code>lbp</code> - Local Binary Patterns","text":"<p>Extracts and visualizes LBP texture descriptors.</p> <pre><code>imvf lbp path/to/image.jpg\n</code></pre>"},{"location":"cli/#power-spectrum-power-spectrum-analysis","title":"<code>power-spectrum</code> - Power Spectrum Analysis","text":"<p>Analyzes and visualizes frequency domain characteristics.</p> <pre><code>imvf power-spectrum path/to/image.jpg\n</code></pre>"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#basic-examples","title":"Basic Examples","text":"<pre><code># Visualize all features\nimvf all input_image.jpg\n\n# Visualize only HoG features\nimvf hog input_image.jpg\n\n# Visualize keypoints\nimvf keypoint input_image.jpg\n\n# Visualize color channels\nimvf color-channel input_image.jpg\n</code></pre>"},{"location":"cli/#using-with-different-image-formats","title":"Using with Different Image Formats","text":"<pre><code># Works with various image formats\nimvf all image.jpg\nimvf gradient image.png\nimvf hog image.bmp\n</code></pre>"},{"location":"cli/#features","title":"Features","text":""},{"location":"cli/#built-with-typer","title":"Built with Typer","text":"<p>The CLI is built with Typer, providing:</p> <ul> <li>Beautiful help messages with formatted output</li> <li>Shell completion support (install with <code>imvf --install-completion</code>)</li> <li>Type-safe arguments with automatic validation</li> <li>Intuitive subcommand structure</li> </ul>"},{"location":"cli/#auto-completion","title":"Auto-completion","text":"<p>Install shell completion for enhanced productivity:</p> <pre><code># Install completion for your shell\nimvf --install-completion\n\n# Show completion script\nimvf --show-completion\n</code></pre>"},{"location":"cli/#implementation-details","title":"Implementation Details","text":"<p>The CLI is implemented in the <code>imvf.cli</code> module using the Typer framework.</p>"},{"location":"cli/#imvf.cli.app","title":"imvf.cli.app  <code>module-attribute</code>","text":"<pre><code>app = Typer(help='ImgVisFeat: Visualize image features')\n</code></pre>"},{"location":"cli/#error-handling","title":"Error Handling","text":"<p>If an error occurs during the visualization process:</p> <ul> <li>Error messages are printed to stderr</li> <li>The command exits with code 1</li> <li>A helpful error message indicates what went wrong</li> </ul> <p>Example error output:</p> <pre><code>$ imvf all nonexistent.jpg\nError: Image not found: nonexistent.jpg\nVisualization failed.\n</code></pre>"},{"location":"cli/#output","title":"Output","text":"<p>All visualization methods:</p> <ul> <li>Display results in OpenCV windows</li> <li>Save results to a directory named after the input image</li> <li>Print progress information to stdout</li> </ul> <p>Example output:</p> <pre><code>$ imvf all sample.jpg\nVisualizing sample.jpg\nNumber of keypoints (SIFT) : 957\nNumber of keypoints (AKAZE): 513\nNumber of keypoints (ORB): 500\nVisualization complete.\n</code></pre>"},{"location":"cli/#notes","title":"Notes","text":"<ul> <li>Each subcommand represents a specific visualization method</li> <li>The <code>all</code> command runs all available visualization methods</li> <li>Results are automatically saved to an output directory</li> <li>Press any key in the OpenCV window to close the visualization</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you install and start using ImgVisFeat.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python &gt;= 3.10</li> </ul>"},{"location":"getting-started/#install-from-pypi","title":"Install from PyPI","text":"<p>Install ImgVisFeat using pip:</p> <pre><code>pip install ImgVisFeat\n</code></pre>"},{"location":"getting-started/#verify-installation","title":"Verify Installation","text":"<p>Verify that ImgVisFeat is installed correctly:</p> <pre><code>import imvf\nprint(imvf.__version__)\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":""},{"location":"getting-started/#using-the-all-in-one-visualizer","title":"Using the All-in-One Visualizer","text":"<p>The simplest way to use ImgVisFeat is with the <code>Visualizer</code> class, which applies all visualization methods:</p> <pre><code>import imvf\n\n# Create visualizer instance\nvisualizer = imvf.Visualizer()\n\n# Visualize all features and save results\nvisualizer.visualize(\"path/to/image.jpg\")\n</code></pre> <p>This will:</p> <ol> <li>Display all visualizations in OpenCV windows</li> <li>Save the results to a directory named after the image (e.g., <code>path/to/image/</code>)</li> </ol>"},{"location":"getting-started/#using-individual-visualizers","title":"Using Individual Visualizers","text":"<p>For more control, use individual visualizers:</p> <pre><code>import cv2\nimport imvf\n\n# Load image\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Color channel visualization\ncolor_visualizer = imvf.ColorChannelVisualizer()\nresult = color_visualizer(image)\n\n# Access individual channels\ncv2.imshow(\"Blue Channel\", result.blue)\ncv2.imshow(\"Green Channel\", result.green)\ncv2.imshow(\"Red Channel\", result.red)\ncv2.waitKey(0)\n</code></pre>"},{"location":"getting-started/#using-the-command-line-interface","title":"Using the Command Line Interface","text":"<p>ImgVisFeat provides a CLI for quick visualizations:</p> <pre><code># Visualize all features\nimvf path/to/image.jpg\n\n# Visualize specific method\nimvf path/to/image.jpg --method hog\n</code></pre> <p>Available methods:</p> <ul> <li><code>all</code> - All visualization methods (default)</li> <li><code>color_channel</code> - RGB channel visualization</li> <li><code>gradient</code> - Gradient visualization</li> <li><code>hog</code> - Histogram of Oriented Gradients</li> <li><code>lbp</code> - Local Binary Patterns</li> <li><code>keypoint</code> - Keypoint detection (SIFT, AKAZE, ORB)</li> <li><code>power_spectrum</code> - Power spectrum analysis</li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the User Guide for detailed usage of each visualizer</li> <li>Check the CLI Reference for command-line options</li> <li>Browse the API Reference for complete documentation</li> </ul>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#import-error","title":"Import Error","text":"<p>If you encounter import errors, ensure that:</p> <ol> <li>ImgVisFeat is installed in your current environment</li> <li>You're using Python &gt;= 3.10</li> <li>All dependencies are installed</li> </ol>"},{"location":"getting-started/#opencv-display-issues","title":"OpenCV Display Issues","text":"<p>If images don't display:</p> <ol> <li>Ensure you have a GUI backend available</li> <li>Add <code>cv2.waitKey(0)</code> after <code>cv2.imshow()</code> calls</li> <li>Use <code>cv2.destroyAllWindows()</code> to close all windows</li> </ol>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the documentation</li> <li>Search existing GitHub issues</li> <li>Open a new issue with details about your problem</li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for ImgVisFeat.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>ImgVisFeat follows a consistent design pattern:</p> <ol> <li>All visualizers inherit from <code>AbstractVisualizer</code></li> <li>Each visualizer implements a <code>__call__</code> method</li> <li>Visualizers return typed dataclass results</li> <li>Results contain visualization images as NumPy arrays</li> </ol>"},{"location":"api/#quick-reference","title":"Quick Reference","text":""},{"location":"api/#individual-visualizers","title":"Individual Visualizers","text":"Visualizer Input Output Use Case <code>ColorChannelVisualizer</code> RGB image <code>ColorChannelResult</code> Color channel extraction <code>ColorGradientVisualizer</code> RGB image <code>GradientResult</code> Gradient for color images <code>GrayGradientVisualizer</code> Grayscale image <code>GradientResult</code> Gradient for grayscale images <code>HoGVisualizer</code> Any image <code>HogResult</code> Object detection features <code>LBPVisualizer</code> Any image <code>LBPResult</code> Texture features <code>KeypointVisualizer</code> Any image <code>KeypointResult</code> Keypoint detection <code>PowerSpectrumVisualizer</code> Any image <code>PowerSpectrumResult</code> Frequency analysis"},{"location":"api/#detailed-documentation","title":"Detailed Documentation","text":"<ul> <li>Visualizers - Complete visualizer class documentation</li> <li>Result Types - Result type documentation</li> </ul>"},{"location":"api/#type-hints","title":"Type Hints","text":"<p>All functions and methods include full type hints for better IDE support:</p> <pre><code>from numpy.typing import NDArray\nimport numpy as np\n\ndef process_image(image: NDArray[np.uint8]) -&gt; ColorChannelResult:\n    ...\n</code></pre>"},{"location":"api/results/","title":"Result Types","text":"<p>This section covers the result types returned by each visualizer.</p>"},{"location":"api/results/#type-module","title":"Type Module","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/results/#imvf.type","title":"imvf.type","text":""},{"location":"api/results/#imvf.type.VisualizationResult","title":"VisualizationResult","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for visualization results.</p> <p>This class provides common functionality for all visualization results, including validation and immutability.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class VisualizationResult(BaseModel):\n    \"\"\"Base class for visualization results.\n\n    This class provides common functionality for all visualization results,\n    including validation and immutability.\n    \"\"\"\n\n    model_config = ConfigDict(\n        frozen=True,  # Make instances immutable\n        arbitrary_types_allowed=True,  # Allow NumPy arrays\n    )\n\n    @field_validator(\"*\", mode=\"before\")\n    @classmethod\n    def _validate_numpy_array(cls, v: Any) -&gt; ImageArray:\n        \"\"\"Validate NumPy array with uint8 dtype and 2D/3D shape.\n\n        Args:\n            v: The value to validate.\n\n        Returns:\n            The validated NumPy array with dtype uint8.\n\n        Raises:\n            ValueError: If validation fails.\n        \"\"\"\n        if not isinstance(v, np.ndarray):\n            raise ValueError(f\"Expected numpy.ndarray, got {type(v).__name__}\")\n\n        if v.dtype != np.uint8:\n            raise ValueError(f\"Expected dtype uint8, got {v.dtype}\")\n\n        if v.ndim not in (2, 3):\n            raise ValueError(f\"Expected 2D or 3D array, got {v.ndim}D\")\n\n        return v\n</code></pre>"},{"location":"api/results/#imvf.type.ColorChannelResult","title":"ColorChannelResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing color channel results.</p> <p>Attributes:</p> Name Type Description <code>blue</code> <code>ImageArray</code> <p>Blue channel as uint8 array.</p> <code>green</code> <code>ImageArray</code> <p>Green channel as uint8 array.</p> <code>red</code> <code>ImageArray</code> <p>Red channel as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class ColorChannelResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing color channel results.\n\n    Attributes:\n        blue: Blue channel as uint8 array.\n        green: Green channel as uint8 array.\n        red: Red channel as uint8 array.\n    \"\"\"\n\n    blue: ImageArray\n    green: ImageArray\n    red: ImageArray\n</code></pre>"},{"location":"api/results/#imvf.type.GradientResult","title":"GradientResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing gradient results.</p> <p>Attributes:</p> Name Type Description <code>gradient_x</code> <code>ImageArray</code> <p>Gradient in x direction as uint8 array.</p> <code>gradient_y</code> <code>ImageArray</code> <p>Gradient in y direction as uint8 array.</p> <code>gradient_xy</code> <code>ImageArray</code> <p>Gradient in xy direction as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class GradientResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing gradient results.\n\n    Attributes:\n        gradient_x: Gradient in x direction as uint8 array.\n        gradient_y: Gradient in y direction as uint8 array.\n        gradient_xy: Gradient in xy direction as uint8 array.\n    \"\"\"\n\n    gradient_x: ImageArray\n    gradient_y: ImageArray\n    gradient_xy: ImageArray\n</code></pre>"},{"location":"api/results/#imvf.type.PowerSpectrumResult","title":"PowerSpectrumResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing power spectrum results.</p> <p>Attributes:</p> Name Type Description <code>power_spectrum</code> <code>ImageArray</code> <p>Power spectrum as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class PowerSpectrumResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing power spectrum results.\n\n    Attributes:\n        power_spectrum: Power spectrum as uint8 array.\n    \"\"\"\n\n    power_spectrum: ImageArray\n</code></pre>"},{"location":"api/results/#imvf.type.HogResult","title":"HogResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing Histogram of Oriented Gradient results.</p> <p>Attributes:</p> Name Type Description <code>hog</code> <code>ImageArray</code> <p>HoG features as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class HogResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing Histogram of Oriented Gradient results.\n\n    Attributes:\n        hog: HoG features as uint8 array.\n    \"\"\"\n\n    hog: ImageArray\n</code></pre>"},{"location":"api/results/#imvf.type.LBPResult","title":"LBPResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing Local Binary Pattern results.</p> <p>Attributes:</p> Name Type Description <code>lbp</code> <code>ImageArray</code> <p>LBP features as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class LBPResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing Local Binary Pattern results.\n\n    Attributes:\n        lbp: LBP features as uint8 array.\n    \"\"\"\n\n    lbp: ImageArray\n</code></pre>"},{"location":"api/results/#imvf.type.KeypointResult","title":"KeypointResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing keypoint results.</p> <p>Attributes:</p> Name Type Description <code>keypoint</code> <code>ImageArray</code> <p>Keypoint positions as uint8 array.</p> <code>rich_keypoint</code> <code>ImageArray</code> <p>Rich keypoint visualization as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class KeypointResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing keypoint results.\n\n    Attributes:\n        keypoint: Keypoint positions as uint8 array.\n        rich_keypoint: Rich keypoint visualization as uint8 array.\n    \"\"\"\n\n    keypoint: ImageArray\n    rich_keypoint: ImageArray\n</code></pre>"},{"location":"api/results/#colorchannelresult","title":"ColorChannelResult","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/results/#imvf.type.ColorChannelResult","title":"imvf.type.ColorChannelResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing color channel results.</p> <p>Attributes:</p> Name Type Description <code>blue</code> <code>ImageArray</code> <p>Blue channel as uint8 array.</p> <code>green</code> <code>ImageArray</code> <p>Green channel as uint8 array.</p> <code>red</code> <code>ImageArray</code> <p>Red channel as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class ColorChannelResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing color channel results.\n\n    Attributes:\n        blue: Blue channel as uint8 array.\n        green: Green channel as uint8 array.\n        red: Red channel as uint8 array.\n    \"\"\"\n\n    blue: ImageArray\n    green: ImageArray\n    red: ImageArray\n</code></pre>"},{"location":"api/results/#gradientresult","title":"GradientResult","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/results/#imvf.type.GradientResult","title":"imvf.type.GradientResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing gradient results.</p> <p>Attributes:</p> Name Type Description <code>gradient_x</code> <code>ImageArray</code> <p>Gradient in x direction as uint8 array.</p> <code>gradient_y</code> <code>ImageArray</code> <p>Gradient in y direction as uint8 array.</p> <code>gradient_xy</code> <code>ImageArray</code> <p>Gradient in xy direction as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class GradientResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing gradient results.\n\n    Attributes:\n        gradient_x: Gradient in x direction as uint8 array.\n        gradient_y: Gradient in y direction as uint8 array.\n        gradient_xy: Gradient in xy direction as uint8 array.\n    \"\"\"\n\n    gradient_x: ImageArray\n    gradient_y: ImageArray\n    gradient_xy: ImageArray\n</code></pre>"},{"location":"api/results/#powerspectrumresult","title":"PowerSpectrumResult","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/results/#imvf.type.PowerSpectrumResult","title":"imvf.type.PowerSpectrumResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing power spectrum results.</p> <p>Attributes:</p> Name Type Description <code>power_spectrum</code> <code>ImageArray</code> <p>Power spectrum as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class PowerSpectrumResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing power spectrum results.\n\n    Attributes:\n        power_spectrum: Power spectrum as uint8 array.\n    \"\"\"\n\n    power_spectrum: ImageArray\n</code></pre>"},{"location":"api/results/#hogresult","title":"HogResult","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/results/#imvf.type.HogResult","title":"imvf.type.HogResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing Histogram of Oriented Gradient results.</p> <p>Attributes:</p> Name Type Description <code>hog</code> <code>ImageArray</code> <p>HoG features as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class HogResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing Histogram of Oriented Gradient results.\n\n    Attributes:\n        hog: HoG features as uint8 array.\n    \"\"\"\n\n    hog: ImageArray\n</code></pre>"},{"location":"api/results/#lbpresult","title":"LBPResult","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/results/#imvf.type.LBPResult","title":"imvf.type.LBPResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing Local Binary Pattern results.</p> <p>Attributes:</p> Name Type Description <code>lbp</code> <code>ImageArray</code> <p>LBP features as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class LBPResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing Local Binary Pattern results.\n\n    Attributes:\n        lbp: LBP features as uint8 array.\n    \"\"\"\n\n    lbp: ImageArray\n</code></pre>"},{"location":"api/results/#keypointresult","title":"KeypointResult","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/results/#imvf.type.KeypointResult","title":"imvf.type.KeypointResult","text":"<p>               Bases: <code>VisualizationResult</code></p> <p>A Pydantic model for storing keypoint results.</p> <p>Attributes:</p> Name Type Description <code>keypoint</code> <code>ImageArray</code> <p>Keypoint positions as uint8 array.</p> <code>rich_keypoint</code> <code>ImageArray</code> <p>Rich keypoint visualization as uint8 array.</p> Source code in <code>src/imvf/type.py</code> <pre><code>class KeypointResult(VisualizationResult):\n    \"\"\"A Pydantic model for storing keypoint results.\n\n    Attributes:\n        keypoint: Keypoint positions as uint8 array.\n        rich_keypoint: Rich keypoint visualization as uint8 array.\n    \"\"\"\n\n    keypoint: ImageArray\n    rich_keypoint: ImageArray\n</code></pre>"},{"location":"api/visualizers/","title":"Visualizers","text":"<p>This section covers all the visualizer classes provided by ImgVisFeat.</p>"},{"location":"api/visualizers/#base-visualizer","title":"Base Visualizer","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/visualizers/#imvf.Visualizer","title":"imvf.Visualizer","text":"<p>Module for image visualization in the ImgVisFeat package.</p> <p>This module contains the Visualizer class, which provides functionality for loading, processing, and displaying or saving visualized images. It supports various visualization parameters and options to enhance image representation for analysis and presentation purposes.</p> <p>Classes:</p> Name Description <code>Visualizer</code> <p>Main class for image visualization operations.</p>"},{"location":"api/visualizers/#imvf.Visualizer.Visualizer","title":"Visualizer","text":"<p>A class for visualizing images.</p> <p>This class provides functionality to visualize images, with options to display them on screen or save them to a specified directory.</p> <p>Attributes:</p> Name Type Description <code>params</code> <code>dict</code> <p>Additional parameters for visualization.</p> Example <p>vis = Visualizer() vis.visualize('path/to/image.jpg', dst_root='output_folder')</p> Source code in <code>src/imvf/Visualizer.py</code> <pre><code>class Visualizer:\n    \"\"\"A class for visualizing images.\n\n    This class provides functionality to visualize images, with options\n    to display them on screen or save them to a specified directory.\n\n    Attributes:\n        params (dict): Additional parameters for visualization.\n\n    Example:\n        &gt;&gt;&gt; vis = Visualizer()\n        &gt;&gt;&gt; vis.visualize('path/to/image.jpg', dst_root='output_folder')\n    \"\"\"\n\n    def __init__(self, **params: dict) -&gt; None:\n        \"\"\"Initialize the Visualizer.\n\n        Args:\n            **params: Additional parameters for visualization.\n                These can include color maps, scaling factors, etc.\n        \"\"\"\n        self.color_channel_visualizer = ColorChannelVisualizer()\n        self.hog_visualizer = HoGVisualizer()\n        self.power_spectrum_visualizer = PowerSpectrumVisualizer()\n        self.sift_visualizer = KeypointVisualizer(\"SIFT\")\n        self.akaze_visualizer = KeypointVisualizer(\"AKAZE\")\n        self.orb_visualizer = KeypointVisualizer(\"ORB\")\n        self.color_gradient_visualizer = ColorGradientVisualizer()\n        self.gray_gradient_visualizer = GrayGradientVisualizer()\n        self.lbp_visualizer = LBPVisualizer()\n\n    def visualize(self, src_image_path: str) -&gt; None:\n        \"\"\"Visualize the image.\n\n        This method loads an image from the given path, applies any\n        visualization parameters, and either displays the image or\n        saves it to the specified destination.\n\n        Args:\n            src_image_path (str): Path to the source image file.\n\n        Example:\n            &gt;&gt;&gt; visualizer = Visualizer()\n            &gt;&gt;&gt; visualizer.visualize('input.jpg', dst_root='output')\n        \"\"\"\n        print(f\"Visualizing {src_image_path}\")\n        self.check_image_assertions(src_image_path)\n        name, _ = os.path.splitext(os.path.basename(src_image_path))\n        image = cv2.imread(src_image_path).astype(\"uint8\")\n        color_channel_result = self.color_channel_visualizer(image)\n        gradient_result = self.color_gradient_visualizer(image)\n        gray_gradient_result = self.gray_gradient_visualizer(image)\n        hog_result = self.hog_visualizer(image)\n        power_spectrum_result = self.power_spectrum_visualizer(image)\n        sift_result = self.sift_visualizer(image)\n        akaze_result = self.akaze_visualizer(image)\n        orb_result = self.orb_visualizer(image)\n        lbp_result = self.lbp_visualizer(image)\n\n        os.makedirs(name, exist_ok=True)\n        dst_path = os.path.join(name, \"%s.png\")\n        cv2.imwrite(dst_path % \"original\", image)\n        cv2.imwrite(dst_path % \"channel_blue\", color_channel_result.blue)\n        cv2.imwrite(dst_path % \"channel_green\", color_channel_result.green)\n        cv2.imwrite(dst_path % \"channel_red\", color_channel_result.red)\n        cv2.imwrite(dst_path % \"color_gradient_x\", gradient_result.gradient_x)\n        cv2.imwrite(dst_path % \"color_gradient_y\", gradient_result.gradient_y)\n        cv2.imwrite(dst_path % \"color_gradient_xy\", gradient_result.gradient_xy)\n        cv2.imwrite(dst_path % \"gray_gradient_x\", gray_gradient_result.gradient_x)\n        cv2.imwrite(dst_path % \"gray_gradient_y\", gray_gradient_result.gradient_y)\n        cv2.imwrite(dst_path % \"gray_gradient_xy\", gray_gradient_result.gradient_xy)\n        cv2.imwrite(dst_path % \"hog\", hog_result.hog)\n        cv2.imwrite(dst_path % \"power_spectrum\", power_spectrum_result.power_spectrum)\n        cv2.imwrite(dst_path % \"keypoint_sift_position\", sift_result.keypoint)\n        cv2.imwrite(dst_path % \"keypoint_sift_rich\", sift_result.rich_keypoint)\n        cv2.imwrite(dst_path % \"keypoint_akaze_position\", akaze_result.keypoint)\n        cv2.imwrite(dst_path % \"keypoint_akaze_rich\", akaze_result.rich_keypoint)\n        cv2.imwrite(dst_path % \"keypoint_orb_position\", orb_result.keypoint)\n        cv2.imwrite(dst_path % \"keypoint_orb_rich\", orb_result.rich_keypoint)\n        cv2.imwrite(dst_path % \"lbp\", lbp_result.lbp)\n\n        cv2.imshow(\"Original\", image)\n        cv2.imshow(\"Blue Channel\", color_channel_result.blue)\n        cv2.imshow(\"Green Channel\", color_channel_result.green)\n        cv2.imshow(\"Red Channel\", color_channel_result.red)\n        cv2.imshow(\"Color Gradient X\", gradient_result.gradient_x)\n        cv2.imshow(\"Color Gradient Y\", gradient_result.gradient_y)\n        cv2.imshow(\"Color Gradient X and Y\", gradient_result.gradient_xy)\n        cv2.imshow(\"Gray Gradient X\", gray_gradient_result.gradient_x)\n        cv2.imshow(\"Gray Gradient Y\", gray_gradient_result.gradient_y)\n        cv2.imshow(\"Gray Gradient X and Y\", gray_gradient_result.gradient_xy)\n        cv2.imshow(\"HoG\", hog_result.hog)\n        cv2.imshow(\"Power Spectrum\", power_spectrum_result.power_spectrum)\n        cv2.imshow(\"SIFT keypoint\", sift_result.keypoint)\n        cv2.imshow(\"SIFT rich keypoint\", sift_result.rich_keypoint)\n        cv2.imshow(\"AKAZE keypoint\", akaze_result.keypoint)\n        cv2.imshow(\"AKAZE rich keypoint\", akaze_result.rich_keypoint)\n        cv2.imshow(\"ORB keypoint\", orb_result.keypoint)\n        cv2.imshow(\"ORB rich keypoint\", orb_result.rich_keypoint)\n        cv2.imshow(\"LBP\", lbp_result.lbp)\n        cv2.waitKey(0)\n        cv2.destroyAllWindows()\n\n    def check_image_assertions(self, src_image_path: str) -&gt; None:\n        \"\"\"Check if the image path is valid.\n\n        Args:\n            src_image_path (str): Path to the image.\n\n        Raises:\n            FileNotFoundError: If the image is not found.\n            IsADirectoryError: If the image path is not a file.\n            ValueError: If the image path is not a image.\n        \"\"\"\n        if not os.path.exists(src_image_path):\n            raise FileNotFoundError(f\"Image not found: {src_image_path}\")\n        elif not os.path.isfile(src_image_path):\n            raise IsADirectoryError(\n                f\"Image path must be a file, but got {src_image_path}\"\n            )\n        try:\n            image = cv2.imread(src_image_path)\n            _ = image.shape\n        except AttributeError:\n            raise ValueError(f\"Image not found: {src_image_path}\")\n</code></pre>"},{"location":"api/visualizers/#imvf.Visualizer.Visualizer.__init__","title":"__init__","text":"<pre><code>__init__(**params: dict) -&gt; None\n</code></pre> <p>Initialize the Visualizer.</p> <p>Parameters:</p> Name Type Description Default <code>**params</code> <code>dict</code> <p>Additional parameters for visualization. These can include color maps, scaling factors, etc.</p> <code>{}</code> Source code in <code>src/imvf/Visualizer.py</code> <pre><code>def __init__(self, **params: dict) -&gt; None:\n    \"\"\"Initialize the Visualizer.\n\n    Args:\n        **params: Additional parameters for visualization.\n            These can include color maps, scaling factors, etc.\n    \"\"\"\n    self.color_channel_visualizer = ColorChannelVisualizer()\n    self.hog_visualizer = HoGVisualizer()\n    self.power_spectrum_visualizer = PowerSpectrumVisualizer()\n    self.sift_visualizer = KeypointVisualizer(\"SIFT\")\n    self.akaze_visualizer = KeypointVisualizer(\"AKAZE\")\n    self.orb_visualizer = KeypointVisualizer(\"ORB\")\n    self.color_gradient_visualizer = ColorGradientVisualizer()\n    self.gray_gradient_visualizer = GrayGradientVisualizer()\n    self.lbp_visualizer = LBPVisualizer()\n</code></pre>"},{"location":"api/visualizers/#imvf.Visualizer.Visualizer.visualize","title":"visualize","text":"<pre><code>visualize(src_image_path: str) -&gt; None\n</code></pre> <p>Visualize the image.</p> <p>This method loads an image from the given path, applies any visualization parameters, and either displays the image or saves it to the specified destination.</p> <p>Parameters:</p> Name Type Description Default <code>src_image_path</code> <code>str</code> <p>Path to the source image file.</p> required Example <p>visualizer = Visualizer() visualizer.visualize('input.jpg', dst_root='output')</p> Source code in <code>src/imvf/Visualizer.py</code> <pre><code>def visualize(self, src_image_path: str) -&gt; None:\n    \"\"\"Visualize the image.\n\n    This method loads an image from the given path, applies any\n    visualization parameters, and either displays the image or\n    saves it to the specified destination.\n\n    Args:\n        src_image_path (str): Path to the source image file.\n\n    Example:\n        &gt;&gt;&gt; visualizer = Visualizer()\n        &gt;&gt;&gt; visualizer.visualize('input.jpg', dst_root='output')\n    \"\"\"\n    print(f\"Visualizing {src_image_path}\")\n    self.check_image_assertions(src_image_path)\n    name, _ = os.path.splitext(os.path.basename(src_image_path))\n    image = cv2.imread(src_image_path).astype(\"uint8\")\n    color_channel_result = self.color_channel_visualizer(image)\n    gradient_result = self.color_gradient_visualizer(image)\n    gray_gradient_result = self.gray_gradient_visualizer(image)\n    hog_result = self.hog_visualizer(image)\n    power_spectrum_result = self.power_spectrum_visualizer(image)\n    sift_result = self.sift_visualizer(image)\n    akaze_result = self.akaze_visualizer(image)\n    orb_result = self.orb_visualizer(image)\n    lbp_result = self.lbp_visualizer(image)\n\n    os.makedirs(name, exist_ok=True)\n    dst_path = os.path.join(name, \"%s.png\")\n    cv2.imwrite(dst_path % \"original\", image)\n    cv2.imwrite(dst_path % \"channel_blue\", color_channel_result.blue)\n    cv2.imwrite(dst_path % \"channel_green\", color_channel_result.green)\n    cv2.imwrite(dst_path % \"channel_red\", color_channel_result.red)\n    cv2.imwrite(dst_path % \"color_gradient_x\", gradient_result.gradient_x)\n    cv2.imwrite(dst_path % \"color_gradient_y\", gradient_result.gradient_y)\n    cv2.imwrite(dst_path % \"color_gradient_xy\", gradient_result.gradient_xy)\n    cv2.imwrite(dst_path % \"gray_gradient_x\", gray_gradient_result.gradient_x)\n    cv2.imwrite(dst_path % \"gray_gradient_y\", gray_gradient_result.gradient_y)\n    cv2.imwrite(dst_path % \"gray_gradient_xy\", gray_gradient_result.gradient_xy)\n    cv2.imwrite(dst_path % \"hog\", hog_result.hog)\n    cv2.imwrite(dst_path % \"power_spectrum\", power_spectrum_result.power_spectrum)\n    cv2.imwrite(dst_path % \"keypoint_sift_position\", sift_result.keypoint)\n    cv2.imwrite(dst_path % \"keypoint_sift_rich\", sift_result.rich_keypoint)\n    cv2.imwrite(dst_path % \"keypoint_akaze_position\", akaze_result.keypoint)\n    cv2.imwrite(dst_path % \"keypoint_akaze_rich\", akaze_result.rich_keypoint)\n    cv2.imwrite(dst_path % \"keypoint_orb_position\", orb_result.keypoint)\n    cv2.imwrite(dst_path % \"keypoint_orb_rich\", orb_result.rich_keypoint)\n    cv2.imwrite(dst_path % \"lbp\", lbp_result.lbp)\n\n    cv2.imshow(\"Original\", image)\n    cv2.imshow(\"Blue Channel\", color_channel_result.blue)\n    cv2.imshow(\"Green Channel\", color_channel_result.green)\n    cv2.imshow(\"Red Channel\", color_channel_result.red)\n    cv2.imshow(\"Color Gradient X\", gradient_result.gradient_x)\n    cv2.imshow(\"Color Gradient Y\", gradient_result.gradient_y)\n    cv2.imshow(\"Color Gradient X and Y\", gradient_result.gradient_xy)\n    cv2.imshow(\"Gray Gradient X\", gray_gradient_result.gradient_x)\n    cv2.imshow(\"Gray Gradient Y\", gray_gradient_result.gradient_y)\n    cv2.imshow(\"Gray Gradient X and Y\", gray_gradient_result.gradient_xy)\n    cv2.imshow(\"HoG\", hog_result.hog)\n    cv2.imshow(\"Power Spectrum\", power_spectrum_result.power_spectrum)\n    cv2.imshow(\"SIFT keypoint\", sift_result.keypoint)\n    cv2.imshow(\"SIFT rich keypoint\", sift_result.rich_keypoint)\n    cv2.imshow(\"AKAZE keypoint\", akaze_result.keypoint)\n    cv2.imshow(\"AKAZE rich keypoint\", akaze_result.rich_keypoint)\n    cv2.imshow(\"ORB keypoint\", orb_result.keypoint)\n    cv2.imshow(\"ORB rich keypoint\", orb_result.rich_keypoint)\n    cv2.imshow(\"LBP\", lbp_result.lbp)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n</code></pre>"},{"location":"api/visualizers/#imvf.Visualizer.Visualizer.check_image_assertions","title":"check_image_assertions","text":"<pre><code>check_image_assertions(src_image_path: str) -&gt; None\n</code></pre> <p>Check if the image path is valid.</p> <p>Parameters:</p> Name Type Description Default <code>src_image_path</code> <code>str</code> <p>Path to the image.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the image is not found.</p> <code>IsADirectoryError</code> <p>If the image path is not a file.</p> <code>ValueError</code> <p>If the image path is not a image.</p> Source code in <code>src/imvf/Visualizer.py</code> <pre><code>def check_image_assertions(self, src_image_path: str) -&gt; None:\n    \"\"\"Check if the image path is valid.\n\n    Args:\n        src_image_path (str): Path to the image.\n\n    Raises:\n        FileNotFoundError: If the image is not found.\n        IsADirectoryError: If the image path is not a file.\n        ValueError: If the image path is not a image.\n    \"\"\"\n    if not os.path.exists(src_image_path):\n        raise FileNotFoundError(f\"Image not found: {src_image_path}\")\n    elif not os.path.isfile(src_image_path):\n        raise IsADirectoryError(\n            f\"Image path must be a file, but got {src_image_path}\"\n        )\n    try:\n        image = cv2.imread(src_image_path)\n        _ = image.shape\n    except AttributeError:\n        raise ValueError(f\"Image not found: {src_image_path}\")\n</code></pre>"},{"location":"api/visualizers/#color-channel-visualizer","title":"Color Channel Visualizer","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/visualizers/#imvf.ColorChannelVisualizer","title":"imvf.ColorChannelVisualizer","text":""},{"location":"api/visualizers/#imvf.ColorChannelVisualizer.ColorChannelVisualizer","title":"ColorChannelVisualizer","text":"<p>               Bases: <code>AbstractVisualizer</code></p> <p>A class for splitting the color channels of an image.</p> Source code in <code>src/imvf/ColorChannelVisualizer.py</code> <pre><code>class ColorChannelVisualizer(AbstractVisualizer):\n    \"\"\"A class for splitting the color channels of an image.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the ColorChannelVisualizer class.\"\"\"\n        pass\n\n    def __call__(self, source: NDArray[np.uint8]) -&gt; ColorChannelResult:\n        \"\"\"Split the color channels of an image.\n\n        Args:\n            source (NDArray[np.uint8]): The source image.\n\n        Returns:\n            ColorChannelResult: The blue, green, and red color channels.\n        \"\"\"\n        image = source.copy()\n        if image.ndim != 3:\n            image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR).astype(np.uint8)\n        blue = np.zeros_like(image, dtype=np.uint8)\n        green = np.zeros_like(image, dtype=np.uint8)\n        red = np.zeros_like(image, dtype=np.uint8)\n        blue[:, :, 0] = image[:, :, 0]\n        green[:, :, 1] = image[:, :, 1]\n        red[:, :, 2] = image[:, :, 2]\n        return ColorChannelResult(blue=blue, green=green, red=red)\n</code></pre>"},{"location":"api/visualizers/#imvf.ColorChannelVisualizer.ColorChannelVisualizer.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize the ColorChannelVisualizer class.</p> Source code in <code>src/imvf/ColorChannelVisualizer.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the ColorChannelVisualizer class.\"\"\"\n    pass\n</code></pre>"},{"location":"api/visualizers/#imvf.ColorChannelVisualizer.ColorChannelVisualizer.__call__","title":"__call__","text":"<pre><code>__call__(source: NDArray[uint8]) -&gt; ColorChannelResult\n</code></pre> <p>Split the color channels of an image.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>NDArray[uint8]</code> <p>The source image.</p> required <p>Returns:</p> Name Type Description <code>ColorChannelResult</code> <code>ColorChannelResult</code> <p>The blue, green, and red color channels.</p> Source code in <code>src/imvf/ColorChannelVisualizer.py</code> <pre><code>def __call__(self, source: NDArray[np.uint8]) -&gt; ColorChannelResult:\n    \"\"\"Split the color channels of an image.\n\n    Args:\n        source (NDArray[np.uint8]): The source image.\n\n    Returns:\n        ColorChannelResult: The blue, green, and red color channels.\n    \"\"\"\n    image = source.copy()\n    if image.ndim != 3:\n        image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR).astype(np.uint8)\n    blue = np.zeros_like(image, dtype=np.uint8)\n    green = np.zeros_like(image, dtype=np.uint8)\n    red = np.zeros_like(image, dtype=np.uint8)\n    blue[:, :, 0] = image[:, :, 0]\n    green[:, :, 1] = image[:, :, 1]\n    red[:, :, 2] = image[:, :, 2]\n    return ColorChannelResult(blue=blue, green=green, red=red)\n</code></pre>"},{"location":"api/visualizers/#gradient-visualizers","title":"Gradient Visualizers","text":""},{"location":"api/visualizers/#color-gradient-visualizer","title":"Color Gradient Visualizer","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/visualizers/#imvf.ColorGradientVisualizer","title":"imvf.ColorGradientVisualizer","text":"<p>               Bases: <code>AbstractVisualizer</code></p> <p>A class for computing the gradient of a color image.</p> Source code in <code>src/imvf/GradientVisualizer.py</code> <pre><code>class ColorGradientVisualizer(AbstractVisualizer):\n    \"\"\"A class for computing the gradient of a color image.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the ColorGradientVisualizer class.\"\"\"\n        pass\n\n    def __call__(self, source: NDArray[np.uint8]) -&gt; GradientResult:\n        \"\"\"Compute the gradient of a color image.\n\n        Args:\n            source (NDArray[np.uint8]): The source image.\n\n        Returns:\n            GradientResult: The gradient in the x, y, and xy directions.\n        \"\"\"\n        image = source.copy()\n        if image.ndim != 3:\n            image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR).astype(np.uint8)\n        grad_x = np.zeros_like(image, dtype=np.uint8)\n        grad_y = np.zeros_like(image, dtype=np.uint8)\n        grad_xy = np.zeros_like(image, dtype=np.uint8)\n        kernel_x = np.array([[0, 0, 0], [-1, 0, 1], [0, 0, 0]], np.float32)\n        kernel_y = np.array([[0, 1, 0], [0, 0, 0], [0, -1, 0]], np.float32)\n        kernel_xy = np.array([[0, 1, 0], [-1, 0, 1], [0, -1, 0]], np.float32)\n        grad_x[:, :, 0] = cv2.filter2D(image[:, :, 0], -1, kernel_x).astype(np.uint8)\n        grad_y[:, :, 0] = cv2.filter2D(image[:, :, 0], -1, kernel_y).astype(np.uint8)\n        grad_xy[:, :, 0] = cv2.filter2D(image[:, :, 0], -1, kernel_xy).astype(np.uint8)\n        grad_x[:, :, 1] = cv2.filter2D(image[:, :, 1], -1, kernel_x).astype(np.uint8)\n        grad_y[:, :, 1] = cv2.filter2D(image[:, :, 1], -1, kernel_y).astype(np.uint8)\n        grad_xy[:, :, 1] = cv2.filter2D(image[:, :, 1], -1, kernel_xy).astype(np.uint8)\n        grad_x[:, :, 2] = cv2.filter2D(image[:, :, 2], -1, kernel_x).astype(np.uint8)\n        grad_y[:, :, 2] = cv2.filter2D(image[:, :, 2], -1, kernel_y).astype(np.uint8)\n        grad_xy[:, :, 2] = cv2.filter2D(image[:, :, 2], -1, kernel_xy).astype(np.uint8)\n        return GradientResult(gradient_x=grad_x, gradient_y=grad_y, gradient_xy=grad_xy)\n</code></pre>"},{"location":"api/visualizers/#imvf.ColorGradientVisualizer.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize the ColorGradientVisualizer class.</p> Source code in <code>src/imvf/GradientVisualizer.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the ColorGradientVisualizer class.\"\"\"\n    pass\n</code></pre>"},{"location":"api/visualizers/#imvf.ColorGradientVisualizer.__call__","title":"__call__","text":"<pre><code>__call__(source: NDArray[uint8]) -&gt; GradientResult\n</code></pre> <p>Compute the gradient of a color image.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>NDArray[uint8]</code> <p>The source image.</p> required <p>Returns:</p> Name Type Description <code>GradientResult</code> <code>GradientResult</code> <p>The gradient in the x, y, and xy directions.</p> Source code in <code>src/imvf/GradientVisualizer.py</code> <pre><code>def __call__(self, source: NDArray[np.uint8]) -&gt; GradientResult:\n    \"\"\"Compute the gradient of a color image.\n\n    Args:\n        source (NDArray[np.uint8]): The source image.\n\n    Returns:\n        GradientResult: The gradient in the x, y, and xy directions.\n    \"\"\"\n    image = source.copy()\n    if image.ndim != 3:\n        image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR).astype(np.uint8)\n    grad_x = np.zeros_like(image, dtype=np.uint8)\n    grad_y = np.zeros_like(image, dtype=np.uint8)\n    grad_xy = np.zeros_like(image, dtype=np.uint8)\n    kernel_x = np.array([[0, 0, 0], [-1, 0, 1], [0, 0, 0]], np.float32)\n    kernel_y = np.array([[0, 1, 0], [0, 0, 0], [0, -1, 0]], np.float32)\n    kernel_xy = np.array([[0, 1, 0], [-1, 0, 1], [0, -1, 0]], np.float32)\n    grad_x[:, :, 0] = cv2.filter2D(image[:, :, 0], -1, kernel_x).astype(np.uint8)\n    grad_y[:, :, 0] = cv2.filter2D(image[:, :, 0], -1, kernel_y).astype(np.uint8)\n    grad_xy[:, :, 0] = cv2.filter2D(image[:, :, 0], -1, kernel_xy).astype(np.uint8)\n    grad_x[:, :, 1] = cv2.filter2D(image[:, :, 1], -1, kernel_x).astype(np.uint8)\n    grad_y[:, :, 1] = cv2.filter2D(image[:, :, 1], -1, kernel_y).astype(np.uint8)\n    grad_xy[:, :, 1] = cv2.filter2D(image[:, :, 1], -1, kernel_xy).astype(np.uint8)\n    grad_x[:, :, 2] = cv2.filter2D(image[:, :, 2], -1, kernel_x).astype(np.uint8)\n    grad_y[:, :, 2] = cv2.filter2D(image[:, :, 2], -1, kernel_y).astype(np.uint8)\n    grad_xy[:, :, 2] = cv2.filter2D(image[:, :, 2], -1, kernel_xy).astype(np.uint8)\n    return GradientResult(gradient_x=grad_x, gradient_y=grad_y, gradient_xy=grad_xy)\n</code></pre>"},{"location":"api/visualizers/#gray-gradient-visualizer","title":"Gray Gradient Visualizer","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/visualizers/#imvf.GrayGradientVisualizer","title":"imvf.GrayGradientVisualizer","text":"<p>               Bases: <code>AbstractVisualizer</code></p> <p>A class for computing the gradient of a grayscale image.</p> Source code in <code>src/imvf/GradientVisualizer.py</code> <pre><code>class GrayGradientVisualizer(AbstractVisualizer):\n    \"\"\"A class for computing the gradient of a grayscale image.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the GrayGradientVisualizer class.\"\"\"\n        pass\n\n    def __call__(self, source: NDArray[np.uint8]) -&gt; GradientResult:\n        \"\"\"Compute the gradient of a grayscale image.\n\n        Args:\n            source (NDArray[np.uint8]): The source image.\n\n        Returns:\n            GradientResult: The gradient in the x, y, and xy directions.\n        \"\"\"\n        if source.ndim != 2:\n            gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY).astype(np.uint8)\n        else:\n            gray = source.copy()\n        kernel_x = np.array([[0, 0, 0], [-1, 0, 1], [0, 0, 0]], np.float32)\n        kernel_y = np.array([[0, 1, 0], [0, 0, 0], [0, -1, 0]], np.float32)\n        kernel_xy = np.array([[0, 1, 0], [-1, 0, 1], [0, -1, 0]], np.float32)\n        grad_x = cv2.filter2D(gray, -1, kernel_x).astype(np.uint8)\n        grad_y = cv2.filter2D(gray, -1, kernel_y).astype(np.uint8)\n        grad_xy = cv2.filter2D(gray, -1, kernel_xy).astype(np.uint8)\n        return GradientResult(gradient_x=grad_x, gradient_y=grad_y, gradient_xy=grad_xy)\n</code></pre>"},{"location":"api/visualizers/#imvf.GrayGradientVisualizer.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize the GrayGradientVisualizer class.</p> Source code in <code>src/imvf/GradientVisualizer.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the GrayGradientVisualizer class.\"\"\"\n    pass\n</code></pre>"},{"location":"api/visualizers/#imvf.GrayGradientVisualizer.__call__","title":"__call__","text":"<pre><code>__call__(source: NDArray[uint8]) -&gt; GradientResult\n</code></pre> <p>Compute the gradient of a grayscale image.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>NDArray[uint8]</code> <p>The source image.</p> required <p>Returns:</p> Name Type Description <code>GradientResult</code> <code>GradientResult</code> <p>The gradient in the x, y, and xy directions.</p> Source code in <code>src/imvf/GradientVisualizer.py</code> <pre><code>def __call__(self, source: NDArray[np.uint8]) -&gt; GradientResult:\n    \"\"\"Compute the gradient of a grayscale image.\n\n    Args:\n        source (NDArray[np.uint8]): The source image.\n\n    Returns:\n        GradientResult: The gradient in the x, y, and xy directions.\n    \"\"\"\n    if source.ndim != 2:\n        gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY).astype(np.uint8)\n    else:\n        gray = source.copy()\n    kernel_x = np.array([[0, 0, 0], [-1, 0, 1], [0, 0, 0]], np.float32)\n    kernel_y = np.array([[0, 1, 0], [0, 0, 0], [0, -1, 0]], np.float32)\n    kernel_xy = np.array([[0, 1, 0], [-1, 0, 1], [0, -1, 0]], np.float32)\n    grad_x = cv2.filter2D(gray, -1, kernel_x).astype(np.uint8)\n    grad_y = cv2.filter2D(gray, -1, kernel_y).astype(np.uint8)\n    grad_xy = cv2.filter2D(gray, -1, kernel_xy).astype(np.uint8)\n    return GradientResult(gradient_x=grad_x, gradient_y=grad_y, gradient_xy=grad_xy)\n</code></pre>"},{"location":"api/visualizers/#hog-visualizer","title":"HoG Visualizer","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/visualizers/#imvf.HoGVisualizer","title":"imvf.HoGVisualizer","text":""},{"location":"api/visualizers/#imvf.HoGVisualizer.HoGVisualizer","title":"HoGVisualizer","text":"<p>               Bases: <code>AbstractVisualizer</code></p> <p>A class for visualizing the HoG features of an image.</p> Source code in <code>src/imvf/HoGVisualizer.py</code> <pre><code>class HoGVisualizer(AbstractVisualizer):\n    \"\"\"A class for visualizing the HoG features of an image.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the HoGVisualizer class.\"\"\"\n        pass\n\n    def __call__(self, source: NDArray[np.uint8]) -&gt; HogResult:\n        \"\"\"Compute the HoG features of an image.\n\n        Args:\n            source (NDArray[np.uint8]): The source image.\n\n        Returns:\n            HogResult: The HoG features of the image.\n        \"\"\"\n        if source.ndim != 2:\n            gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY)\n        else:\n            gray = source.copy()\n        _, hog_image = feature.hog(\n            gray,\n            orientations=9,\n            pixels_per_cell=(16, 16),\n            cells_per_block=(2, 2),\n            block_norm=\"L2-Hys\",\n            visualize=True,\n        )\n        hog_image_uint8 = (hog_image * 255).astype(np.uint8)\n        return HogResult(hog=hog_image_uint8)\n</code></pre>"},{"location":"api/visualizers/#imvf.HoGVisualizer.HoGVisualizer.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize the HoGVisualizer class.</p> Source code in <code>src/imvf/HoGVisualizer.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the HoGVisualizer class.\"\"\"\n    pass\n</code></pre>"},{"location":"api/visualizers/#imvf.HoGVisualizer.HoGVisualizer.__call__","title":"__call__","text":"<pre><code>__call__(source: NDArray[uint8]) -&gt; HogResult\n</code></pre> <p>Compute the HoG features of an image.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>NDArray[uint8]</code> <p>The source image.</p> required <p>Returns:</p> Name Type Description <code>HogResult</code> <code>HogResult</code> <p>The HoG features of the image.</p> Source code in <code>src/imvf/HoGVisualizer.py</code> <pre><code>def __call__(self, source: NDArray[np.uint8]) -&gt; HogResult:\n    \"\"\"Compute the HoG features of an image.\n\n    Args:\n        source (NDArray[np.uint8]): The source image.\n\n    Returns:\n        HogResult: The HoG features of the image.\n    \"\"\"\n    if source.ndim != 2:\n        gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY)\n    else:\n        gray = source.copy()\n    _, hog_image = feature.hog(\n        gray,\n        orientations=9,\n        pixels_per_cell=(16, 16),\n        cells_per_block=(2, 2),\n        block_norm=\"L2-Hys\",\n        visualize=True,\n    )\n    hog_image_uint8 = (hog_image * 255).astype(np.uint8)\n    return HogResult(hog=hog_image_uint8)\n</code></pre>"},{"location":"api/visualizers/#keypoint-visualizer","title":"Keypoint Visualizer","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/visualizers/#imvf.KeypointVisualizer","title":"imvf.KeypointVisualizer","text":""},{"location":"api/visualizers/#imvf.KeypointVisualizer.KeypointVisualizer","title":"KeypointVisualizer","text":"<p>               Bases: <code>AbstractVisualizer</code></p> <p>A class for visualizing keypoints in an image.</p> Source code in <code>src/imvf/KeypointVisualizer.py</code> <pre><code>class KeypointVisualizer(AbstractVisualizer):\n    \"\"\"A class for visualizing keypoints in an image.\"\"\"\n\n    def __init__(self, algorithm_name: str) -&gt; None:\n        \"\"\"Initialize the KeypointVisualizer class.\"\"\"\n        if algorithm_name not in [\"AKAZE\", \"SIFT\", \"ORB\"]:\n            raise ValueError(\n                \"Invalid algorithm name. Choose from 'AKAZE', 'SIFT', or 'ORB'.\"\n            )\n        self.algorithm_name = algorithm_name\n\n    def __call__(self, source: NDArray[np.uint8]) -&gt; KeypointResult:\n        \"\"\"Visualize keypoints in an image.\n\n        Args:\n            source (NDArray[np.uint8]): The source image.\n\n        Returns:\n            KeyPointResult: The image with keypoints and the image with rich keypoints.\n        \"\"\"\n        color = source.copy()\n        if source.ndim != 3:\n            color = cv2.cvtColor(source, cv2.COLOR_GRAY2BGR).astype(np.uint8)\n        if self.algorithm_name == \"AKAZE\":\n            kp_image, rich_image = self.make_akaze_image(color)\n        elif self.algorithm_name == \"SIFT\":\n            kp_image, rich_image = self.make_sift_image(color)\n        elif self.algorithm_name == \"ORB\":\n            kp_image, rich_image = self.make_orb_image(color)\n        else:\n            raise ValueError(f\"Invalid algorithm name: {self.algorithm_name}\")\n        return KeypointResult(keypoint=kp_image, rich_keypoint=rich_image)\n\n    def make_akaze_image(\n        self, color: NDArray[np.uint8]\n    ) -&gt; tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n        \"\"\"Create an image with keypoints using the AKAZE algorithm.\n\n        Args:\n            color (NDArray[np.uint8]): The source image.\n\n        Returns:\n            tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n                The image with keypoints and the image with rich keypoints.\n        \"\"\"\n        gray = cv2.cvtColor(color, cv2.COLOR_BGR2GRAY)\n        kp_image = color.copy()\n        rich_image = color.copy()\n        detector = cv2.AKAZE_create()  # type: ignore\n        keypoints = detector.detect(gray)\n        circle_color = (255, 255, 0)\n        for key in keypoints:\n            cv2.circle(\n                kp_image,\n                (np.uint64(key.pt[0]), np.uint64(key.pt[1])),  # type: ignore\n                3,\n                circle_color,\n                1,\n            )\n        cv2.drawKeypoints(\n            rich_image,\n            keypoints,\n            rich_image,\n            flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,\n        )\n        print(f\"Number of keypoints (AKAZE): {len(keypoints)}\")\n        return kp_image, rich_image\n\n    def make_sift_image(\n        self, color: NDArray[np.uint8]\n    ) -&gt; tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n        \"\"\"Create an image with keypoints using the SIFT algorithm.\n\n        Args:\n            color (NDArray[np.uint8]): The source image.\n\n        Returns:\n            tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n                The image with keypoints and the image with rich keypoints.\n        \"\"\"\n        gray = cv2.cvtColor(color, cv2.COLOR_BGR2GRAY)\n        kp_image = color.copy()\n        rich_image = color.copy()\n        detector = cv2.SIFT_create()  # type: ignore\n        keypoints = detector.detect(gray)\n        circle_color = (255, 255, 0)\n        for key in keypoints:\n            cv2.circle(\n                kp_image,\n                (np.uint64(key.pt[0]), np.uint64(key.pt[1])),  # type: ignore\n                3,\n                circle_color,\n                1,\n            )\n        cv2.drawKeypoints(\n            rich_image,\n            keypoints,\n            rich_image,\n            flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,\n        )\n        print(f\"Number of keypoints (SIFT) : {len(keypoints)}\")\n        return kp_image, rich_image\n\n    def make_orb_image(\n        self, color: NDArray[np.uint8]\n    ) -&gt; tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n        \"\"\"Create an image with keypoints using the ORB algorithm.\n\n        Args:\n            color (NDArray[np.uint8]): The source image.\n\n        Returns:\n            tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n                The image with keypoints and the image with rich keypoints.\n        \"\"\"\n        gray = cv2.cvtColor(color, cv2.COLOR_BGR2GRAY)\n        kp_image = color.copy()\n        rich_image = color.copy()\n        detector = cv2.ORB_create()  # type: ignore\n        keypoints = detector.detect(gray)\n        circle_color = (255, 255, 0)\n        cv2.drawKeypoints(kp_image, keypoints, kp_image, color=circle_color)\n        cv2.drawKeypoints(\n            rich_image,\n            keypoints,\n            rich_image,\n            flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,\n        )\n        print(f\"Number of keypoints (ORB): {len(keypoints)}\")\n        return kp_image, rich_image\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the name of the visualizer.\n\n        Returns:\n            str: The name of the visualizer.\n        \"\"\"\n        return f\"{self.__class__.__name__}({self.algorithm_name})\"\n</code></pre>"},{"location":"api/visualizers/#imvf.KeypointVisualizer.KeypointVisualizer.__init__","title":"__init__","text":"<pre><code>__init__(algorithm_name: str) -&gt; None\n</code></pre> <p>Initialize the KeypointVisualizer class.</p> Source code in <code>src/imvf/KeypointVisualizer.py</code> <pre><code>def __init__(self, algorithm_name: str) -&gt; None:\n    \"\"\"Initialize the KeypointVisualizer class.\"\"\"\n    if algorithm_name not in [\"AKAZE\", \"SIFT\", \"ORB\"]:\n        raise ValueError(\n            \"Invalid algorithm name. Choose from 'AKAZE', 'SIFT', or 'ORB'.\"\n        )\n    self.algorithm_name = algorithm_name\n</code></pre>"},{"location":"api/visualizers/#imvf.KeypointVisualizer.KeypointVisualizer.__call__","title":"__call__","text":"<pre><code>__call__(source: NDArray[uint8]) -&gt; KeypointResult\n</code></pre> <p>Visualize keypoints in an image.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>NDArray[uint8]</code> <p>The source image.</p> required <p>Returns:</p> Name Type Description <code>KeyPointResult</code> <code>KeypointResult</code> <p>The image with keypoints and the image with rich keypoints.</p> Source code in <code>src/imvf/KeypointVisualizer.py</code> <pre><code>def __call__(self, source: NDArray[np.uint8]) -&gt; KeypointResult:\n    \"\"\"Visualize keypoints in an image.\n\n    Args:\n        source (NDArray[np.uint8]): The source image.\n\n    Returns:\n        KeyPointResult: The image with keypoints and the image with rich keypoints.\n    \"\"\"\n    color = source.copy()\n    if source.ndim != 3:\n        color = cv2.cvtColor(source, cv2.COLOR_GRAY2BGR).astype(np.uint8)\n    if self.algorithm_name == \"AKAZE\":\n        kp_image, rich_image = self.make_akaze_image(color)\n    elif self.algorithm_name == \"SIFT\":\n        kp_image, rich_image = self.make_sift_image(color)\n    elif self.algorithm_name == \"ORB\":\n        kp_image, rich_image = self.make_orb_image(color)\n    else:\n        raise ValueError(f\"Invalid algorithm name: {self.algorithm_name}\")\n    return KeypointResult(keypoint=kp_image, rich_keypoint=rich_image)\n</code></pre>"},{"location":"api/visualizers/#imvf.KeypointVisualizer.KeypointVisualizer.make_akaze_image","title":"make_akaze_image","text":"<pre><code>make_akaze_image(color: NDArray[uint8]) -&gt; tuple[NDArray[uint8], NDArray[uint8]]\n</code></pre> <p>Create an image with keypoints using the AKAZE algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>NDArray[uint8]</code> <p>The source image.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray[uint8], NDArray[uint8]]</code> <p>tuple[NDArray[np.uint8], NDArray[np.uint8]]: The image with keypoints and the image with rich keypoints.</p> Source code in <code>src/imvf/KeypointVisualizer.py</code> <pre><code>def make_akaze_image(\n    self, color: NDArray[np.uint8]\n) -&gt; tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n    \"\"\"Create an image with keypoints using the AKAZE algorithm.\n\n    Args:\n        color (NDArray[np.uint8]): The source image.\n\n    Returns:\n        tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n            The image with keypoints and the image with rich keypoints.\n    \"\"\"\n    gray = cv2.cvtColor(color, cv2.COLOR_BGR2GRAY)\n    kp_image = color.copy()\n    rich_image = color.copy()\n    detector = cv2.AKAZE_create()  # type: ignore\n    keypoints = detector.detect(gray)\n    circle_color = (255, 255, 0)\n    for key in keypoints:\n        cv2.circle(\n            kp_image,\n            (np.uint64(key.pt[0]), np.uint64(key.pt[1])),  # type: ignore\n            3,\n            circle_color,\n            1,\n        )\n    cv2.drawKeypoints(\n        rich_image,\n        keypoints,\n        rich_image,\n        flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,\n    )\n    print(f\"Number of keypoints (AKAZE): {len(keypoints)}\")\n    return kp_image, rich_image\n</code></pre>"},{"location":"api/visualizers/#imvf.KeypointVisualizer.KeypointVisualizer.make_sift_image","title":"make_sift_image","text":"<pre><code>make_sift_image(color: NDArray[uint8]) -&gt; tuple[NDArray[uint8], NDArray[uint8]]\n</code></pre> <p>Create an image with keypoints using the SIFT algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>NDArray[uint8]</code> <p>The source image.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray[uint8], NDArray[uint8]]</code> <p>tuple[NDArray[np.uint8], NDArray[np.uint8]]: The image with keypoints and the image with rich keypoints.</p> Source code in <code>src/imvf/KeypointVisualizer.py</code> <pre><code>def make_sift_image(\n    self, color: NDArray[np.uint8]\n) -&gt; tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n    \"\"\"Create an image with keypoints using the SIFT algorithm.\n\n    Args:\n        color (NDArray[np.uint8]): The source image.\n\n    Returns:\n        tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n            The image with keypoints and the image with rich keypoints.\n    \"\"\"\n    gray = cv2.cvtColor(color, cv2.COLOR_BGR2GRAY)\n    kp_image = color.copy()\n    rich_image = color.copy()\n    detector = cv2.SIFT_create()  # type: ignore\n    keypoints = detector.detect(gray)\n    circle_color = (255, 255, 0)\n    for key in keypoints:\n        cv2.circle(\n            kp_image,\n            (np.uint64(key.pt[0]), np.uint64(key.pt[1])),  # type: ignore\n            3,\n            circle_color,\n            1,\n        )\n    cv2.drawKeypoints(\n        rich_image,\n        keypoints,\n        rich_image,\n        flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,\n    )\n    print(f\"Number of keypoints (SIFT) : {len(keypoints)}\")\n    return kp_image, rich_image\n</code></pre>"},{"location":"api/visualizers/#imvf.KeypointVisualizer.KeypointVisualizer.make_orb_image","title":"make_orb_image","text":"<pre><code>make_orb_image(color: NDArray[uint8]) -&gt; tuple[NDArray[uint8], NDArray[uint8]]\n</code></pre> <p>Create an image with keypoints using the ORB algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>NDArray[uint8]</code> <p>The source image.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray[uint8], NDArray[uint8]]</code> <p>tuple[NDArray[np.uint8], NDArray[np.uint8]]: The image with keypoints and the image with rich keypoints.</p> Source code in <code>src/imvf/KeypointVisualizer.py</code> <pre><code>def make_orb_image(\n    self, color: NDArray[np.uint8]\n) -&gt; tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n    \"\"\"Create an image with keypoints using the ORB algorithm.\n\n    Args:\n        color (NDArray[np.uint8]): The source image.\n\n    Returns:\n        tuple[NDArray[np.uint8], NDArray[np.uint8]]:\n            The image with keypoints and the image with rich keypoints.\n    \"\"\"\n    gray = cv2.cvtColor(color, cv2.COLOR_BGR2GRAY)\n    kp_image = color.copy()\n    rich_image = color.copy()\n    detector = cv2.ORB_create()  # type: ignore\n    keypoints = detector.detect(gray)\n    circle_color = (255, 255, 0)\n    cv2.drawKeypoints(kp_image, keypoints, kp_image, color=circle_color)\n    cv2.drawKeypoints(\n        rich_image,\n        keypoints,\n        rich_image,\n        flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS,\n    )\n    print(f\"Number of keypoints (ORB): {len(keypoints)}\")\n    return kp_image, rich_image\n</code></pre>"},{"location":"api/visualizers/#imvf.KeypointVisualizer.KeypointVisualizer.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the name of the visualizer.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the visualizer.</p> Source code in <code>src/imvf/KeypointVisualizer.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the name of the visualizer.\n\n    Returns:\n        str: The name of the visualizer.\n    \"\"\"\n    return f\"{self.__class__.__name__}({self.algorithm_name})\"\n</code></pre>"},{"location":"api/visualizers/#lbp-visualizer","title":"LBP Visualizer","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/visualizers/#imvf.LBPVisualizer","title":"imvf.LBPVisualizer","text":""},{"location":"api/visualizers/#imvf.LBPVisualizer.LBPVisualizer","title":"LBPVisualizer","text":"<p>               Bases: <code>AbstractVisualizer</code></p> <p>A class for computing the Local Binary Pattern (LBP) of an image.</p> Source code in <code>src/imvf/LBPVisualizer.py</code> <pre><code>class LBPVisualizer(AbstractVisualizer):\n    \"\"\"A class for computing the Local Binary Pattern (LBP) of an image.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the LBPVisualizer class.\"\"\"\n        pass\n\n    def __call__(self, source: NDArray[np.uint8]) -&gt; LBPResult:\n        \"\"\"Compute the Local Binary Pattern (LBP) of an image.\n\n        Args:\n            source (NDArray[np.uint8]): The source image.\n\n        Returns:\n            LBPResult: The LBP image.\n        \"\"\"\n        if source.ndim != 2:\n            gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY)\n        else:\n            gray = source.copy()\n        counter = 0\n        lbp = 8 * [0]\n        lbp_image = np.zeros((gray.shape[0] - 2, gray.shape[1] - 2), dtype=np.uint8)\n        for centerY in range(1, gray.shape[0] - 1):\n            for centerX in range(1, gray.shape[1] - 1):\n                for yy in range(centerY - 1, centerY + 2):\n                    for xx in range(centerX - 1, centerX + 2):\n                        if (xx != centerX) or (yy != centerY):\n                            if gray[centerY, centerX] &gt;= gray[yy, xx]:\n                                lbp[counter] = 0\n                            else:\n                                lbp[counter] = 1\n                            counter += 1\n                lbp_pix = (\n                    lbp[0] * 2**7\n                    + lbp[1] * 2**6\n                    + lbp[2] * 2**5\n                    + lbp[4] * 2**4\n                    + lbp[7] * 2**3\n                    + lbp[6] * 2**2\n                    + lbp[5] * 2**1\n                    + lbp[3] * 2**0\n                )\n                lbp_image[centerY - 1, centerX - 1] = lbp_pix\n                counter = 0\n        lbp_image = cv2.copyMakeBorder(  # type: ignore\n            lbp_image, 1, 1, 1, 1, cv2.BORDER_CONSTANT, value=0\n        )\n        return LBPResult(lbp=lbp_image)\n</code></pre>"},{"location":"api/visualizers/#imvf.LBPVisualizer.LBPVisualizer.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize the LBPVisualizer class.</p> Source code in <code>src/imvf/LBPVisualizer.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the LBPVisualizer class.\"\"\"\n    pass\n</code></pre>"},{"location":"api/visualizers/#imvf.LBPVisualizer.LBPVisualizer.__call__","title":"__call__","text":"<pre><code>__call__(source: NDArray[uint8]) -&gt; LBPResult\n</code></pre> <p>Compute the Local Binary Pattern (LBP) of an image.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>NDArray[uint8]</code> <p>The source image.</p> required <p>Returns:</p> Name Type Description <code>LBPResult</code> <code>LBPResult</code> <p>The LBP image.</p> Source code in <code>src/imvf/LBPVisualizer.py</code> <pre><code>def __call__(self, source: NDArray[np.uint8]) -&gt; LBPResult:\n    \"\"\"Compute the Local Binary Pattern (LBP) of an image.\n\n    Args:\n        source (NDArray[np.uint8]): The source image.\n\n    Returns:\n        LBPResult: The LBP image.\n    \"\"\"\n    if source.ndim != 2:\n        gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY)\n    else:\n        gray = source.copy()\n    counter = 0\n    lbp = 8 * [0]\n    lbp_image = np.zeros((gray.shape[0] - 2, gray.shape[1] - 2), dtype=np.uint8)\n    for centerY in range(1, gray.shape[0] - 1):\n        for centerX in range(1, gray.shape[1] - 1):\n            for yy in range(centerY - 1, centerY + 2):\n                for xx in range(centerX - 1, centerX + 2):\n                    if (xx != centerX) or (yy != centerY):\n                        if gray[centerY, centerX] &gt;= gray[yy, xx]:\n                            lbp[counter] = 0\n                        else:\n                            lbp[counter] = 1\n                        counter += 1\n            lbp_pix = (\n                lbp[0] * 2**7\n                + lbp[1] * 2**6\n                + lbp[2] * 2**5\n                + lbp[4] * 2**4\n                + lbp[7] * 2**3\n                + lbp[6] * 2**2\n                + lbp[5] * 2**1\n                + lbp[3] * 2**0\n            )\n            lbp_image[centerY - 1, centerX - 1] = lbp_pix\n            counter = 0\n    lbp_image = cv2.copyMakeBorder(  # type: ignore\n        lbp_image, 1, 1, 1, 1, cv2.BORDER_CONSTANT, value=0\n    )\n    return LBPResult(lbp=lbp_image)\n</code></pre>"},{"location":"api/visualizers/#power-spectrum-visualizer","title":"Power Spectrum Visualizer","text":"<p>options: show_root_heading: true show_source: true</p>"},{"location":"api/visualizers/#imvf.PowerSpectrumVisualizer","title":"imvf.PowerSpectrumVisualizer","text":""},{"location":"api/visualizers/#imvf.PowerSpectrumVisualizer.PowerSpectrumVisualizer","title":"PowerSpectrumVisualizer","text":"<p>               Bases: <code>AbstractVisualizer</code></p> <p>A class for computing the power spectrum of an image.</p> Source code in <code>src/imvf/PowerSpectrumVisualizer.py</code> <pre><code>class PowerSpectrumVisualizer(AbstractVisualizer):\n    \"\"\"A class for computing the power spectrum of an image.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the PowerSpectrumVisualizer class.\"\"\"\n        pass\n\n    def __call__(self, source: NDArray[np.uint8]) -&gt; PowerSpectrumResult:\n        \"\"\"Compute the power spectrum of an image.\n\n        Args:\n            source (NDArray[np.uint8]): The source image.\n\n        Returns:\n            PowerSpectrumResult: The power spectrum of the image.\n        \"\"\"\n        if source.ndim != 2:\n            gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY)\n        else:\n            gray = source.copy()\n        gray = np.array(gray)\n        fft = np.fft.fft2(gray)\n        fft = np.fft.fftshift(fft)\n        pow = np.abs(fft) ** 2\n        pow = np.log10(pow)\n        p_max = np.max(pow)\n        pow = pow / p_max * 255\n        pow_image = np.array(np.uint8(pow))\n\n        return PowerSpectrumResult(power_spectrum=pow_image)\n</code></pre>"},{"location":"api/visualizers/#imvf.PowerSpectrumVisualizer.PowerSpectrumVisualizer.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize the PowerSpectrumVisualizer class.</p> Source code in <code>src/imvf/PowerSpectrumVisualizer.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the PowerSpectrumVisualizer class.\"\"\"\n    pass\n</code></pre>"},{"location":"api/visualizers/#imvf.PowerSpectrumVisualizer.PowerSpectrumVisualizer.__call__","title":"__call__","text":"<pre><code>__call__(source: NDArray[uint8]) -&gt; PowerSpectrumResult\n</code></pre> <p>Compute the power spectrum of an image.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>NDArray[uint8]</code> <p>The source image.</p> required <p>Returns:</p> Name Type Description <code>PowerSpectrumResult</code> <code>PowerSpectrumResult</code> <p>The power spectrum of the image.</p> Source code in <code>src/imvf/PowerSpectrumVisualizer.py</code> <pre><code>def __call__(self, source: NDArray[np.uint8]) -&gt; PowerSpectrumResult:\n    \"\"\"Compute the power spectrum of an image.\n\n    Args:\n        source (NDArray[np.uint8]): The source image.\n\n    Returns:\n        PowerSpectrumResult: The power spectrum of the image.\n    \"\"\"\n    if source.ndim != 2:\n        gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY)\n    else:\n        gray = source.copy()\n    gray = np.array(gray)\n    fft = np.fft.fft2(gray)\n    fft = np.fft.fftshift(fft)\n    pow = np.abs(fft) ** 2\n    pow = np.log10(pow)\n    p_max = np.max(pow)\n    pow = pow / p_max * 255\n    pow_image = np.array(np.uint8(pow))\n\n    return PowerSpectrumResult(power_spectrum=pow_image)\n</code></pre>"},{"location":"guide/","title":"User Guide","text":"<p>This guide provides detailed information on using each visualizer in ImgVisFeat.</p>"},{"location":"guide/#available-visualizers","title":"Available Visualizers","text":"<p>ImgVisFeat provides several specialized visualizers for different types of image analysis:</p>"},{"location":"guide/#feature-extraction","title":"Feature Extraction","text":"<ul> <li>Color Channels - Extract and visualize RGB color channels</li> <li>Gradients - Compute and visualize image gradients</li> <li>HoG Features - Histogram of Oriented Gradients for object detection</li> <li>LBP Features - Local Binary Patterns for texture analysis</li> <li>Keypoint Detection - Detect and visualize keypoints (SIFT, AKAZE, ORB)</li> <li>Power Spectrum - Frequency domain analysis</li> </ul>"},{"location":"guide/#all-in-one","title":"All-in-One","text":"<ul> <li>Visualizer Class - Apply all visualizations at once</li> </ul>"},{"location":"guide/#common-usage-pattern","title":"Common Usage Pattern","text":"<p>All individual visualizers follow the same usage pattern:</p> <pre><code>import cv2\nimport imvf\n\n# Load image\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Create visualizer\nvisualizer = imvf.SomeVisualizer()\n\n# Apply visualization\nresult = visualizer(image)\n\n# Access results\n# Results are dataclass instances with specific fields\n</code></pre>"},{"location":"guide/#result-types","title":"Result Types","text":"<p>Each visualizer returns a typed result object containing the visualization results:</p> <ul> <li><code>ColorChannelResult</code> - Blue, Green, Red channels</li> <li><code>GradientResult</code> - Gradient X, Y, XY</li> <li><code>HogResult</code> - HoG visualization</li> <li><code>LBPResult</code> - LBP visualization</li> <li><code>KeypointResult</code> - Keypoint and rich keypoint images</li> <li><code>PowerSpectrumResult</code> - Power spectrum visualization</li> </ul> <p>See the API Reference for complete details on each result type.</p>"},{"location":"guide/color-channels/","title":"Color Channel Visualization","text":"<p>Extract and visualize individual RGB color channels from an image.</p>"},{"location":"guide/color-channels/#usage","title":"Usage","text":"<pre><code>import cv2\nimport imvf\n\n# Load image\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Create visualizer\nvisualizer = imvf.ColorChannelVisualizer()\n\n# Apply visualization\nresult = visualizer(image)\n\n# Display results\ncv2.imshow(\"Blue Channel\", result.blue)\ncv2.imshow(\"Green Channel\", result.green)\ncv2.imshow(\"Red Channel\", result.red)\ncv2.waitKey(0)\n</code></pre>"},{"location":"guide/color-channels/#result-structure","title":"Result Structure","text":"<p>The <code>ColorChannelResult</code> dataclass contains:</p> <ul> <li><code>blue</code>: Blue channel as grayscale image</li> <li><code>green</code>: Green channel as grayscale image</li> <li><code>red</code>: Red channel as grayscale image</li> </ul>"},{"location":"guide/color-channels/#use-cases","title":"Use Cases","text":"<ul> <li>Analyzing color distribution in images</li> <li>Identifying dominant color channels</li> <li>Preprocessing for color-based feature extraction</li> <li>Understanding color composition</li> </ul>"},{"location":"guide/color-channels/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>ColorChannelResult - Result type details</li> </ul>"},{"location":"guide/gradients/","title":"Gradient Visualization","text":"<p>Compute and visualize image gradients in X, Y, and combined XY directions.</p>"},{"location":"guide/gradients/#visualizers","title":"Visualizers","text":"<p>ImgVisFeat provides two gradient visualizers:</p>"},{"location":"guide/gradients/#colorgradientvisualizer","title":"ColorGradientVisualizer","text":"<p>For color (RGB) images.</p> <pre><code>import cv2\nimport imvf\n\n# Load color image\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Create visualizer\nvisualizer = imvf.ColorGradientVisualizer()\n\n# Apply visualization\nresult = visualizer(image)\n\n# Display results\ncv2.imshow(\"Gradient X\", result.gradient_x)\ncv2.imshow(\"Gradient Y\", result.gradient_y)\ncv2.imshow(\"Gradient XY\", result.gradient_xy)\ncv2.waitKey(0)\n</code></pre>"},{"location":"guide/gradients/#graygradientvisualizer","title":"GrayGradientVisualizer","text":"<p>For grayscale images.</p> <pre><code>import cv2\nimport imvf\n\n# Load and convert to grayscale\nimage = cv2.imread(\"path/to/image.jpg\")\ngray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n# Create visualizer\nvisualizer = imvf.GrayGradientVisualizer()\n\n# Apply visualization\nresult = visualizer(gray)\n\n# Display results\ncv2.imshow(\"Gradient X\", result.gradient_x)\ncv2.imshow(\"Gradient Y\", result.gradient_y)\ncv2.imshow(\"Gradient XY\", result.gradient_xy)\ncv2.waitKey(0)\n</code></pre>"},{"location":"guide/gradients/#result-structure","title":"Result Structure","text":"<p>The <code>GradientResult</code> dataclass contains:</p> <ul> <li><code>gradient_x</code>: Gradient in X direction (horizontal)</li> <li><code>gradient_y</code>: Gradient in Y direction (vertical)</li> <li><code>gradient_xy</code>: Combined gradient magnitude</li> </ul>"},{"location":"guide/gradients/#use-cases","title":"Use Cases","text":"<ul> <li>Edge detection</li> <li>Feature extraction for object recognition</li> <li>Image analysis and preprocessing</li> <li>Understanding directional changes in images</li> </ul>"},{"location":"guide/gradients/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>GradientResult - Result type details</li> </ul>"},{"location":"guide/hog/","title":"HoG (Histogram of Oriented Gradients)","text":"<p>Visualize HoG feature descriptors commonly used for object detection and recognition.</p>"},{"location":"guide/hog/#usage","title":"Usage","text":"<pre><code>import cv2\nimport imvf\n\n# Load image\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Create visualizer\nvisualizer = imvf.HoGVisualizer()\n\n# Apply visualization\nresult = visualizer(image)\n\n# Display result\ncv2.imshow(\"HoG Features\", result.hog)\ncv2.waitKey(0)\n</code></pre>"},{"location":"guide/hog/#result-structure","title":"Result Structure","text":"<p>The <code>HogResult</code> dataclass contains:</p> <ul> <li><code>hog</code>: HoG feature visualization</li> </ul>"},{"location":"guide/hog/#what-is-hog","title":"What is HoG?","text":"<p>HoG (Histogram of Oriented Gradients) is a feature descriptor used in computer vision for object detection. It:</p> <ul> <li>Divides the image into small cells</li> <li>Computes gradient histograms for each cell</li> <li>Normalizes across blocks of cells</li> <li>Creates a feature vector describing the image</li> </ul>"},{"location":"guide/hog/#use-cases","title":"Use Cases","text":"<ul> <li>Object detection (pedestrians, vehicles, etc.)</li> <li>Shape recognition</li> <li>Image classification</li> <li>Feature extraction for machine learning</li> </ul>"},{"location":"guide/hog/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>HogResult - Result type details</li> <li>scikit-image HoG documentation</li> </ul>"},{"location":"guide/keypoints/","title":"Keypoint Detection","text":"<p>Detect and visualize keypoints using SIFT, AKAZE, or ORB algorithms.</p>"},{"location":"guide/keypoints/#usage","title":"Usage","text":"<pre><code>import cv2\nimport imvf\n\n# Load image\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Create visualizer with specific algorithm\nvisualizer = imvf.KeypointVisualizer(algorithm=\"SIFT\")\n\n# Apply visualization\nresult = visualizer(image)\n\n# Display results\ncv2.imshow(\"Keypoints\", result.keypoint)\ncv2.imshow(\"Rich Keypoints\", result.rich_keypoint)\ncv2.waitKey(0)\n</code></pre>"},{"location":"guide/keypoints/#available-algorithms","title":"Available Algorithms","text":""},{"location":"guide/keypoints/#sift-scale-invariant-feature-transform","title":"SIFT (Scale-Invariant Feature Transform)","text":"<pre><code>visualizer = imvf.KeypointVisualizer(algorithm=\"SIFT\")\n</code></pre> <ul> <li>Scale and rotation invariant</li> <li>High quality features</li> <li>Patented (free for research)</li> </ul>"},{"location":"guide/keypoints/#akaze-accelerated-kaze","title":"AKAZE (Accelerated-KAZE)","text":"<pre><code>visualizer = imvf.KeypointVisualizer(algorithm=\"AKAZE\")\n</code></pre> <ul> <li>Fast and efficient</li> <li>Scale and rotation invariant</li> <li>Open source</li> </ul>"},{"location":"guide/keypoints/#orb-oriented-fast-and-rotated-brief","title":"ORB (Oriented FAST and Rotated BRIEF)","text":"<pre><code>visualizer = imvf.KeypointVisualizer(algorithm=\"ORB\")\n</code></pre> <ul> <li>Very fast</li> <li>Rotation invariant</li> <li>Free and open source</li> </ul>"},{"location":"guide/keypoints/#result-structure","title":"Result Structure","text":"<p>The <code>KeypointResult</code> dataclass contains:</p> <ul> <li><code>keypoint</code>: Basic keypoint visualization</li> <li><code>rich_keypoint</code>: Detailed keypoint visualization with size and orientation</li> </ul>"},{"location":"guide/keypoints/#use-cases","title":"Use Cases","text":"<ul> <li>Image matching and alignment</li> <li>Object recognition</li> <li>3D reconstruction</li> <li>Camera tracking</li> <li>Panorama stitching</li> </ul>"},{"location":"guide/keypoints/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>KeypointResult - Result type details</li> <li>OpenCV Feature Detection</li> </ul>"},{"location":"guide/lbp/","title":"LBP (Local Binary Patterns)","text":"<p>Extract LBP texture descriptors for texture classification and analysis.</p>"},{"location":"guide/lbp/#usage","title":"Usage","text":"<pre><code>import cv2\nimport imvf\n\n# Load image\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Create visualizer\nvisualizer = imvf.LBPVisualizer()\n\n# Apply visualization\nresult = visualizer(image)\n\n# Display result\ncv2.imshow(\"LBP Features\", result.lbp)\ncv2.waitKey(0)\n</code></pre>"},{"location":"guide/lbp/#result-structure","title":"Result Structure","text":"<p>The <code>LBPResult</code> dataclass contains:</p> <ul> <li><code>lbp</code>: LBP feature visualization</li> </ul>"},{"location":"guide/lbp/#what-is-lbp","title":"What is LBP?","text":"<p>LBP (Local Binary Patterns) is a texture descriptor that:</p> <ul> <li>Compares each pixel with its neighbors</li> <li>Creates a binary pattern from the comparisons</li> <li>Generates a code describing local texture</li> <li>Is rotation and illumination invariant</li> </ul>"},{"location":"guide/lbp/#use-cases","title":"Use Cases","text":"<ul> <li>Texture classification</li> <li>Face recognition</li> <li>Surface inspection</li> <li>Material identification</li> <li>Medical image analysis</li> </ul>"},{"location":"guide/lbp/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>LBPResult - Result type details</li> <li>scikit-image LBP documentation</li> </ul>"},{"location":"guide/power-spectrum/","title":"Power Spectrum Analysis","text":"<p>Analyze frequency domain characteristics of images using Fourier Transform.</p>"},{"location":"guide/power-spectrum/#usage","title":"Usage","text":"<pre><code>import cv2\nimport imvf\n\n# Load image\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Create visualizer\nvisualizer = imvf.PowerSpectrumVisualizer()\n\n# Apply visualization\nresult = visualizer(image)\n\n# Display result\ncv2.imshow(\"Power Spectrum\", result.power_spectrum)\ncv2.waitKey(0)\n</code></pre>"},{"location":"guide/power-spectrum/#result-structure","title":"Result Structure","text":"<p>The <code>PowerSpectrumResult</code> dataclass contains:</p> <ul> <li><code>power_spectrum</code>: Power spectrum visualization</li> </ul>"},{"location":"guide/power-spectrum/#what-is-power-spectrum","title":"What is Power Spectrum?","text":"<p>Power spectrum analysis:</p> <ul> <li>Converts image to frequency domain using Fourier Transform</li> <li>Shows the magnitude of different frequencies</li> <li>High frequencies represent edges and details</li> <li>Low frequencies represent smooth areas</li> </ul>"},{"location":"guide/power-spectrum/#use-cases","title":"Use Cases","text":"<ul> <li>Image quality assessment</li> <li>Noise analysis</li> <li>Compression analysis</li> <li>Pattern recognition</li> <li>Texture analysis</li> <li>Identifying periodic patterns</li> </ul>"},{"location":"guide/power-spectrum/#see-also","title":"See Also","text":"<ul> <li>API Reference - Complete API documentation</li> <li>PowerSpectrumResult - Result type details</li> <li>Fourier Transform Tutorial</li> </ul>"},{"location":"guide/visualizer/","title":"All-in-One Visualizer","text":"<p>The <code>Visualizer</code> class provides a convenient way to apply all visualization methods at once.</p>"},{"location":"guide/visualizer/#usage","title":"Usage","text":"<pre><code>import imvf\n\n# Create visualizer instance\nvisualizer = imvf.Visualizer()\n\n# Visualize all features\nvisualizer.visualize(\"path/to/image.jpg\")\n</code></pre>"},{"location":"guide/visualizer/#what-it-does","title":"What It Does","text":"<p>The <code>Visualizer</code> class:</p> <ol> <li>Loads the image from the specified path</li> <li>Applies all available visualizers:    - Color Channel Visualization    - Gradient Visualization (both color and grayscale)    - HoG Features    - LBP Features    - Keypoint Detection (SIFT, AKAZE, ORB)    - Power Spectrum</li> <li>Displays all results in OpenCV windows</li> <li>Saves all results to a directory named after the image</li> </ol>"},{"location":"guide/visualizer/#output-directory","title":"Output Directory","text":"<p>Results are saved to a directory structure:</p> <pre><code>path/to/image/\n\u251c\u2500\u2500 color_channels/\n\u2502   \u251c\u2500\u2500 blue.png\n\u2502   \u251c\u2500\u2500 green.png\n\u2502   \u2514\u2500\u2500 red.png\n\u251c\u2500\u2500 gradients/\n\u2502   \u251c\u2500\u2500 gradient_x.png\n\u2502   \u251c\u2500\u2500 gradient_y.png\n\u2502   \u2514\u2500\u2500 gradient_xy.png\n\u251c\u2500\u2500 hog/\n\u2502   \u2514\u2500\u2500 hog.png\n\u251c\u2500\u2500 lbp/\n\u2502   \u2514\u2500\u2500 lbp.png\n\u251c\u2500\u2500 keypoints/\n\u2502   \u251c\u2500\u2500 sift.png\n\u2502   \u251c\u2500\u2500 akaze.png\n\u2502   \u2514\u2500\u2500 orb.png\n\u2514\u2500\u2500 power_spectrum/\n    \u2514\u2500\u2500 power_spectrum.png\n</code></pre>"},{"location":"guide/visualizer/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guide/visualizer/#using-with-pre-loaded-images","title":"Using with Pre-loaded Images","text":"<pre><code>import cv2\nimport imvf\n\n# Load image\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Create visualizer\nvisualizer = imvf.Visualizer()\n\n# Process the loaded image\n# (Note: visualize() expects a path, use individual visualizers for pre-loaded images)\n</code></pre>"},{"location":"guide/visualizer/#accessing-individual-visualizers","title":"Accessing Individual Visualizers","text":"<p>The <code>Visualizer</code> class internally uses individual visualizers. For more control, use them directly:</p> <pre><code>import cv2\nimport imvf\n\nimage = cv2.imread(\"path/to/image.jpg\")\n\n# Use individual visualizers\ncolor_viz = imvf.ColorChannelVisualizer()\nhog_viz = imvf.HoGVisualizer()\n\ncolor_result = color_viz(image)\nhog_result = hog_viz(image)\n</code></pre>"},{"location":"guide/visualizer/#see-also","title":"See Also","text":"<ul> <li>Individual Visualizers - Detailed guides for each visualizer</li> <li>API Reference - Complete API documentation</li> </ul>"}]}